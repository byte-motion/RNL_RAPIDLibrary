MODULE RNL__CNV1
    CONST dataType datatype_CNV1:="CNV1";

    CONST dataPointer CNV1_:=["CNV1","CNV1",0,"","",0,""];

    LOCAL PERS tooldata tool_:=[TRUE,[[0,0,0],[1,0,0,0]],[0,[0,0,0],[1,0,0,0],0,0,0]];
    LOCAL PERS wobjdata wobj_:=[FALSE,FALSE,"CNV1",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];

    LOCAL VAR dnum current_conveyorCode;

    LOCAL VAR dataPointer safetyLimits;


    !initialize
    LOCAL PROC init()
        tool_:=[TRUE,[[0,0,0],[1,0,0,0]],[0,[0,0,0],[1,0,0,0],0,0,0]];
        wobj_:=[FALSE,FALSE,"CNV1",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];
    ENDPROC


    !set the conveyor code
    LOCAL PROC setConveyorCode(dataPointer CNV,dataPointer conveyorCode)
        VAR dnum conveyorCode_;
        conveyorCode_:=dnum_get(conveyorCode);

        !Set conveyor tracking to advanced queue mode
        IF c1PosInJobQ=0 THEN
            SetDO c1PosInJobQ,1;
            PulseDO\PLength:=0.2,c1RemAllPObj;
            WaitTime 0.5;
        ENDIF

        !If conveyorCode is -1 then use the last conveyorCode generated by the system
        IF conveyorCode_=-1 conveyorCode_:=GInputDnum(c1CntFromEnc);

        !Return early if conveyor code is allready active
        IF conveyorCode_=current_conveyorCode RETURN ;

        !Set the conveyorCode
        SetDO c1CntToEncStr,0;
        DropWObj wobj_;
        WaitTime 0.05;
        SetGO c1CntToEnc,conveyorCode_;
        WaitTime 0.05;
        !PulseDO\PLength:=0.2,c1CntToEncStr;
        SetDO c1CntToEncStr,1;
        WaitTime 0.05;
        WaitWObj wobj_\MaxTime:=1;
        SetDO c1CntToEncStr,0;

        !Save what the current conveyorCode is
        current_conveyorCode:=conveyorCode_;

    ERROR
        IF ERRNO=ERR_CNV_NOT_ACT THEN
            ActUnit CNV1;
            RETRY;
        ENDIF
        !RAISE ;
    ENDPROC


    !Set the safety limits
    LOCAL PROC setSafetyLimits(dataPointer pointer,dataPointer safetyShape)
        IF NOT pointer=CNV1_ Stop;
        safetyLimits:=safetyShape;
    ENDPROC

    PROC setSafetyLimits_()
    ENDPROC


    !Do something
    PROC CNV1_action(
        dataPointer target,
        dataPointer point,
        dataPointer approachHeight,
        dataPointer tool,
        dataPointer eventid,
        dataPointer conveyorCode)

        VAR robtarget target_;
        VAR pose point_;
        VAR num approachHeight_;
        VAR num eventid_;
        VAR dnum conveyorCode_;

        VAR event e;

        point_:=pose_get(point);
        approachHeight_:=num_get(approachHeight);
        tool_:=tooldata_get(tool);
        eventid_:=num_get(eventid);
        conveyorCode_:=dnum_get(conveyorCode);

        !Apply the conveyor position
        setConveyorCode CNV1_,conveyorCode;
        
        !Wait until point is within limits
        WaitUntil isInside(safetyLimits, shape_([point_.trans.x+c1Position*1000,point_.trans.y,point_.trans.z]);

        !Move to appoach
        MoveJ Offs(target_,0,0,approachHeight_),vmax,z50,tool_\WObj:=wobj_;

        !Move to target
        MoveJ target_,vmax,fine,tool_\WObj:=wobj_;

        !trigger event if set
        IF eventid_>0 THEN
            e.id:=eventid_;
            TRIGGER\object:=CNV1_,e;
        ENDIF

        !Move to Depart
        MoveJ Offs(target_,0,0,approachHeight_),vmax,z50,tool_\WObj:=wobj_;
        
        

    ENDPROC


    !Checks if a shape(A) contains another shape(B) (point)
    LOCAL PROC contains(dataPointer pointer,dataPointer point,INOUT dataPointer result)
        VAR shape a;
        VAR shape b;
        !result
        VAR bool r:=TRUE;

        TEST b.type
        CASE SHAPE_POINT:

            TEST a.type
            
            CASE SHAPE_AXIS_ALIGNED_BOX:
                IF a.position.rot<>[1,0,0,0] THEN
                    !BAD SHAPE
                ENDIF
                IF r r:=b.position.trans.x<a.position.trans.x+a.boundingBox.x;
                IF r r:=b.position.trans.x>a.position.trans.x;
                IF r r:=b.position.trans.y<a.position.trans.y+a.boundingBox.y;
                IF r r:=b.position.trans.y>a.position.trans.y;
                IF r r:=b.position.trans.z<a.position.trans.z+a.boundingBox.z;
                IF r r:=b.position.trans.z>a.position.trans.z;
                result:=bool_(r);
                RETURN ;

            CASE SHAPE_SPHERE:
                !If the distance from b to center of a is shorter than radi
                IF r r:=VectMagn(
                    [
                    b.position.trans.x-(a.position.trans.x+0.5*a.boundingBox.x),
                    b.position.trans.y-(a.position.trans.y+0.5*a.boundingBox.y),
                    b.position.trans.z-(a.position.trans.z+0.5*a.boundingBox.z)]
                    )>0.5*a.boundingBox.x;
                result:=bool_(r);
                RETURN ;
            
            CASE SHAPE_AXIS_ALIGNED_CYLINDER:
                IF a.position.rot<>[1,0,0,0] THEN
                    !BAD SHAPE
                ENDIF
                IF a.boundingBox.x<>a.boundingBox.y THEN
                    !BAD SHAPE
                ENDIF
                IF r r:=b.position.trans.x<a.position.trans.x+a.boundingBox.x;
                IF r r:=b.position.trans.x>a.position.trans.x;
                IF r r:=b.position.trans.y<a.position.trans.y+a.boundingBox.y;
                IF r r:=b.position.trans.y>a.position.trans.y;
                IF r r:=b.position.trans.z<a.position.trans.z+a.boundingBox.z;
                IF r r:=b.position.trans.z>a.position.trans.z;
                !If the x,y plane distance from b to center of a is shorter than radi
                IF r r:=VectMagn(
                    [
                    b.position.trans.x-(a.position.trans.x+0.5*a.boundingBox.x),
                    b.position.trans.y-(a.position.trans.y+0.5*a.boundingBox.y),
                    0]
                    )<0.5*a.boundingBox.x;
                result:=bool_(r);
                RETURN ;

            CASE SHAPE_BOX:
            CASE SHAPE_BOX:
            CASE SHAPE_CONE:

            DEFAULT:
                !Shape A type not supported, for shape B type
            ENDTEST


        DEFAULT:
            !Shape B type not supported 
        ENDTEST

    ENDPROC




ENDMODULE